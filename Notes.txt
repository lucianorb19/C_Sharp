C# CURSO UDEMY

----------INSTALAÇÕES----------
Visual Studio Comunitty



----------SOBRE A LINGUAGEM----------
LINGUAGEM PRÉ-COMPILADA
CÓDIGO -> PRÉ COMPILAÇÃO NO CIL (COMMON INTERMEDIATE LANGUAGE) -> COMPILAÇÃO JIT(JUST IN TIME) NA CLR (COOMON LANGUAGE RUNTIME) .NET (MÁQUINA VIRTUAL) -> CÓDIGO DE MÁQUINA



CLASSES FORMAM NAMESPACES (AGRUPAMENTO LÓGICO) 
        |
        V
        ASSEMBLYs (AGRUPAMENTO FÍSICO - DLL ou EXE - BUILD - SUBPROJETO) -> APLICAÇÃO



----------MACETES----------
IDENTAÇÃO AUTOMÁTICA - CTRL + K + D
CW+TAB TAB - ESCREVE Console.WriteLine()
SABER O VALOR MÍNIMO OU MÁXIMO DE UM TIPO DE VARIÁVEL NUMÉRICA
int.MinValue;
int.MaxValue;


-----DEBUGGING-----
CRIAR UM BREAKE POINT - LINHA ONDE SERÁ INICIADO O DEBUG - F9
INICIAR O DEBUG - F5
CHEGANDO AO BREAK POINT - EXECUTAR CADA PASSO - F11 (EXECUTA ATÉ O PASSO A PASSO DE FUNÇÕES EXTERNAS) OU F10
INTERROMPER O DEBUG - SHIFT + F5


JANELA Locals - GUARDA OS VALORES DE TODAS AS VARIÁVEIS DO ESCOPO


----------TIPOS DE VARIÁVEIS----------

TIPOS DE VARIÁVEIS - MAIS COMUNS
C#          .Net FrameworkType    Signed   Bytes(tamanho)    Faixa de valor
____________________________________________________________________________
INTEIRO
_______
int         System.Int32          YES      4                 -2.147.438.648 a 2.147.438.647
long        System.Int64          YES      8                 -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807
sbyte       System.SByte          YES      1                 -128 a 127
byte        System.Byte           NO       1                 0 a 255

FLOAT
______
float       System.Single         YES      4                 1.175494351 E - 38 a 3,402823466 E + 38
double      System.Double         YES      8                 2.2250738585072014 E - 308 a 1,7976931348623158 E + 308
decimal     System.Decimal        YES      12                ±1,0 x 10-28 a ±7,9228 x 1028

STRING
______
char        System.Char           -        2     

BOOL
_____
bool        System.Boolean        -        True or False



STRING
CADEIA DE CARACTÉRES - ASPAS DUPLAS
É UM OBJETO (SEU NOME É UM PONTEIRO QUE APONTA PARA SEU VALOR NA MEMÓRIA HEAP)
string nome = "Luciano";


CHAR
REPRESENTA UM ÚNICO CARACTERE - USAR ASPAS SIMPLES
char letra = 'A';

PARA ATRIBUIR VALORES, USAR O CARACTERE DIRETO OU SEU CÓDIGO UNICODE EM https://symbl.cc/pt/unicode-table/
char letra = 'A'
char letra = '\u0041'


OBJECT
TODA VARIÁVEL HERDA DE OBJECT
object nome = "luciano";
object valor = 15;
object numero = 'a';
object x = 40.25f



OVERFLOW DE VARIÁVEL
SEMPRE QUE É ATRIBUÍDO A UMA VARIÁVEL UM VALOR QUE FOGE DO SEU INTERVALO, ELA ASSUME O VALOR OPOSTO. POR EXEMPLO, VARIÁVEIS DO TIPO sbyte ASSUMEM VALORES DE -128 A 127. SE FOR ATRIBUÍDO sbtye x = 128; x vai assumir valor -128.



ESCOPO DE VARIÁVEL
TODA VARIÁVEL PRECISA SER DECLARADA (SEU TIPO) E INICIALIZADA (ATRIBUIR ALGUM VALOR A ELA)
UMA VARIÁVEL DENTRO DE UM ESTRUTURA MENOR NÃO É VISÍVEL FORA DELA
static void Main(...){
        double x = 110;
        if (x>100){
                double desconto = preco * 0.1;
        }
        Console.WriteLine(desconto); //desconto NÃO É VISÍVEL FORA DO IF
}



RECOMENDAÇÕES
long x = 2465795L  (LETRA l AO FINAL DO NÚMERO)
float x = 4.5f (LETRA f AO FINAL DO NÚMERO)
NOMES DE VARIÁVEIS COM CamelCase (lastName)
NOMES DE NAMESPACES, CLASSES, PROPERTIES E MÉTODOS - PascalCase (LastName)
NOMES DE ATRIBUTOS INTERNOS DA CLASSE - _lastName



RESTRIÇÕES DE NOMES DE VARIÁVEL
-NÃO PODE COMEÇAR COM DÍGITO;
-NÃO USAR ACENTO;
-NÃO USAR ESPAÇO EM BRANCO;



----------SAÍDA DE DADOS----------
Console.WriteLine(valor); //MOSTRA NA TELA E QUEBRA A LINHA
Console.Write(valor);//MOSTRA NA TELA SEM QUEBRAR A LINHA - TUDO JUNTO

MOSTRAR UM NÚMERO ESPECÍFICO DE CASAS DECIMAIS DO NÚMERO
double saldo = 50.2589;
Console.WriteLine(saldo.ToString("F2")); //DUAS CASAS DECIMAIS - JÁ ARREDONDADO - 0 A 4 ->0 / 5 A 9 -> 10

TROCAR PONTO POR VÍRGULA
using System.Globalization; //CultureInfo.InvariantCulture
Console.WriteLine(saldo.ToString("F2", CultureInfo.InvariantCulture));//USAR . AO INVÉS DE ,

DIVERSAS VARIÁVEIS NA MESMA SAÍDA
string nome = "Luciano";
double saldo = 50.2589;
int idade = 28;

INTERPOLAÇÃO
Console.WriteLine($"{nome} tem {idade} anos e R${saldo.ToString("f2")} reais na conta!");

PLACEHOLDER
Console.WriteLine("{0} tem {1} anos e R${2:F2} na conta!", nome, idade, saldo);

CONCATENAÇÃO
Console.WriteLine(nome +" tem "+idade+" anos e R$"+saldo.ToString("f2")+" na conta!");



-----ATRIBUIÇÃO-----
= -> RECEBE
a += 2 -> a RECEBE a + 2 (TAMBÉM FUNCIONA COM STRING)
a -= 2 -> ...
a *= 2 -> ...
a /= 2 -> ...
a %= 2 -> a = a%2
a++ -> a=a+1
a-- -> a=a-1

DIFERENÇA ++a E a++
a=10;
b=a++; (B VALE 10 E A VALE 11)

a=10;
b=++a; (B VALE 11 E A VALE 11)

OU SEJA, x=++A - INCREMENTA O a E DEPOIS ATRIBUI SEU VALOR PARA x
         x=a++ - ATIBUI a SEM INCREMENTO A x E DEPOIS INCREMENTA A


-----CONVERSÃO DE TIPOS-----
IMPLÍCITA - ATRIBUIR A UMA VARIÁVEL O VALOR DE OUTRA QUE "CABE" DENTRO DELA
float a = 5.2f;
double b = a; //CONVERSÃO IMPLÍCITA

EXPLÍCITA / CASTING - FORÇAR A CONVERSÃO DO VALOR DE UMA VARIÁVEL PARA OUTRO TIPO, ASSUMINDO O RISCO DA PERDA DE DADOS
double a = 5.2;
float b = (float)a;

CASTING EM OPERAÇÕES
int a = 5;
int b = 2;
double resultado = a / b; //RESULTADO É UM INTEIRO PORQUE O COMPILADOR ENTENDE SOMENTE AS PARTES INTEIRAS DE VARIÁVEIS INTEIRAS PROCESSADAS
double resultado1 = (double) a / b;


-----OPERADORES ARITMÉTICOS-----
+ SOMA
- SUBTRAÇÃO
* MULTIPLICAÇÃO
/ DIVISÃO
% MOD
Math.Pow(x, y) - EXPONENCIAÇÃO -> x elevado a y
Math.Sqrt(x) RAIZ QUADRADA


PRECEDÊNCIA
* / % -> + -
() QUEBRA PRECEDÊNCIA


-----OPERADORES COMPARATIVOS-----
> MAIOR
< MENOR
>= MAIOR OU IGUAL
<= MENOR OU IGUAL
== IGUAL
!= DIFERENTE


---OPERADORES LÓGICOS-----
&& E - 2ª MAIOR PRECEDÊNCIA
|| OU - 3ª MAIOR PRECEDÊNCIA
!  NÃO - MAIOR PRECEDÊNCIA

 

-----ENTRADA DE DADOS-----
Console.ReadLine(); 
LÊ ATÉ A QUEBRA DE LINHA - ENTER
ENTRADA DE DADOS SEMPRE COMO STRING

LER STRINGS DE UM VETOR
string frase = Console.ReadLine();//STRING RECEBE TODAS AS PALAVRAS
string[] vetor = frase.Split(' ');//CADA PALAVRA É SALVA NUMA POSIÇÃO DO VETOR
string p0 = vetor[0];
string p1 = vetor[1];  //CADA PALAVRA É ATRIBUÍDA A UMA NOVA VARIÁVEL
string p2 = vetor[2];

CONVERTER TIPOS NA ENTRADA
int n1 = int.Parse(Consolo.ReadLine());

variavel = tipo_variavel.Parse(Console.ReadLine());

CONVERSÃO DE DECIMAIS COM , OU .
SE A MÁQUINA ESTIVER EM PT-BR, PREENCHER AS VARIÁVEIS COM . DÁ ERRO
double numero = double.Parse(Console.ReadLine()); //ENTRADA 4.55
Console.WriteLine(numero);// SAÍDA 455

PARA QUE FUNCIONE USANDO .
Using System.Globalization
double numero = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture); //ENTRADA 4.55
Console.WriteLine(numero.ToString("f2",CultureInfo.InvariantCulture));// SAÍDA 4.55



-----CONDICIONAL - IF ELSE-----
SIMPLES
if (condicao1){
        comando1
}

COMPOSTA
if(condicao1){
        comando1
}
else{
        comando2
}

ANINHADA/ENCADEADA
if(condicao1){
        comando1
}
else if(condicao2){
        comando2
}
else if(condicao3){
        comando3
}
else{
        comando4
}


-----WHILE-----
while (condicao){
        comando
}



---FOR---
for(inicio; condicao; incremento){
        comando
}


-----FUNÇÕES-----
static <tipo saida> <nome_funcao> (<parametros>){
        <codigo>
        <return variavel>
}

FUNÇÕES AO FINAL, FORA DA MAIN E DENTRO DA CLASS Program - SE ESTIVEREM NO MESMO ARQUIVO .cs

//EXEMPLO
static int Maior_de_tres(int n1, int n2, int n3)
{
    int f_maior = n1;

    if (n2 >= f_maior)
    {
        f_maior = n2;
    }
    else if (n3 >= f_maior)
    {
        f_maior = n3;
    }

    return f_maior;
}


-----ORIENTAÇÃO A OBJETOS-----

CLASSE
TIPO ESTUTURADO QUE PODE CONTER MEMBROS, QUE SÃO:
ATRIBUTOS - DADOS/CAMPOS
MÉTODOS - FUNÇÕES OPERAÇÕES


ALÉM DE:
CONSTRUTORES - 
SOBRECARGA - 
ENCAPSULAMENTO - 
HERANÇA - 
POLIMORFISMO - 

TODA CLASSE EM C# HERDA DA CLASSE OBJECT
NOMES DE ATRIBUTOS - COMEÇANDO MAIÚSCULO
ACESSO A UM ATRIBUTO DA CLASSE COM <objeto da classe>.<nome atributo>

CRIAR CLASSE NO VISUAL STUDIO COMMUNITY
BOTÃO DIREITO NO NAMESPACE ATUAL - ADD - CLASS - NOMEAR (PRIMEIRA LETRA MAIÚSCULA)

EXEMPLO
namespace PrimeiroProjetoOrientadoObjeto
{
    public class Triangulo //PRECISA DO PUBLIC ?
    {
        public double A;
        public double B;
        public double C;

    }
}



NO PROGRAMA PRINCIPAL
INICIALIZAR OBJETOS DO TIPO DA CLASSE E INSTANCIÁ-LOS
namespace PrimerioProjetoOrientadoObjeto
{

    internal class Program
    {
        static void Main(string[] args)
        {
            Triangulo x, y; //INICIALIZAÇÃO DOS OBJETOS TRIÂNGULO

            x = new Triangulo();
            y = new Triangulo();//INSTANCIAÇÃO DOS OBJETOS TRIANGULO

            x.A = 10;
        }
    }
}



-----MÉTODOS-----
public <tipo retorno> <nome método>(<parametros>){
        <codigo>
        return <variavel/valor>
}

NO EXEMPLO DO TRIÂNGULO, UM MÉTODO QUE CALCULE SUA ÁREA

namespace PrimeiroProjetoOrientadoObjeto
{
    class Triangulo //PRECISA DO PUBLIC ?
    {
        public double A;
        public double B;
        public double C;

        public double Area_Triangulo()
        {
            //ÁREA DO TRIÂNGULO CALCULADA PELA FÓRMULA DE HERON
            //FUNÇÃO SEM PARÂMETROS PQ SÓ USA AS PRÓPRIAS INFORMAÇÕES DO OBJETO
            double p = (A + B + C)/2;
            double area_triangulo = Math.Sqrt(p * (p - A) * (p - B) * (p - C));
            return area_triangulo;
         }

    }
}


E NO PROGRAMA PRINCIPAL
//ÁREA DE TRIÂNGULO USANDO CLASSE TRIANGULO E FÓRMULAR DE HERON
Triangulo x, y; //INICIALIZAÇÃO DOS OBJETOS TRIÂNGULO

x = new Triangulo();
y = new Triangulo();//INSTANCIAÇÃO DOS OBJETOS TRIANGULO

Console.WriteLine("Lados primeiro triangulo: ");
x.A = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
x.B = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
x.C = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);

Console.WriteLine("Lados segundo triangulo: ");
y.A = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
y.B = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
y.C = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);

double area_x = x.Area_Triangulo();
double area_y = y.Area_Triangulo();

Console.WriteLine($"Área do triangulo X: {area_x.ToString("f4", CultureInfo.InvariantCulture)}\n" +
                  $"Área do triângulo Y: {area_y.ToString("f4", CultureInfo.InvariantCulture)}");

if (area_x == area_y)
{
    Console.WriteLine("Áreas iguais!");
}
else if (area_x > area_y)
{
    Console.WriteLine("Maior área: triângulo X");
}
else // areay > areax
{
    Console.WriteLine("Maior área: triângulo Y");
}


-----OBJECTS E TO STRING-----
ToString É UM MÉTODO DA CLASSE GENÉRICA OBJECT QUE PODE SER SOBRESPOSTO NA CLASSE DESEJADA.
SUA UTILIDADE É PERMITIR MOSTRAR OS DADOS DO OBJETO DA MANEIRA DESEJADA, PRECISANDO SOMENTE, NO PROGRAMA PRINCIPAL,
INDICAR O NOME DO OBJETO

NO EXEMPLO DA CLASSE PRODUTO
class Produto
{
    public string Nome;
    public double Preco;
    public int Quantidade;

    public double ValorTotalEmEstoque()
    {
        return Preco* Quantidade;
    }

    public override string ToString()
    {
        return $"{Nome}, $ {Preco.ToString("f2",CultureInfo.InvariantCulture)}, " +
            $"quantidade em estoque: {Quantidade}, " +
            $"valor total em estoque: $ {ValorTotalEmEstoque().
            ToString("f2",CultureInfo.InvariantCulture)}";
    }

}


E NO CÓDIGO PRINCIPAL
Console.WriteLine($"Dados do produto: {produto1}");


-----MEMBROS ESTÁTICOS-----
MEMBROS DE CLASSE, SÃO OS QUE FAZEM SENTINDO INDEPENDENTE DO OBJETO INSTANCIADO.
SÃO CHAMADOS DIRETO PELO NOME DA CLASSE.
ATÉ O MOMENTOS, SÓ FOI VISTO MEMBROS DE INSTÂNCIA (ATRIBUTOS E MÉTODOS PARA O OBJETO INSTANCIADO)

APLICAÇÃO
CLASSES UTILITÁRIAS - Math.Sqrt()
DECLARAÇÃO DE CONSTANTES - 

CLASSES COM MEMBROS EXCLUSIVAMENTE ESTÁTICOS, PODEM SER CLASSES ESTÁTICAS.
CLASSES ESTÁTICAS NÃO PODEM SER INSTANCIADAS.

QUANDO USAR CLASSES/MEMBROS ESTÁTICOS ?
QUANDO A LÓGICA DA CLASSE É A MESMA E A ÚNICA MUDANÇA DEPENDE DE INFORMAÇÕES DE VARIÁVEIS EXTERNAS,
E NÃO DE SEUS ATRIBUTOS.

EXEMPLO
-O CÁLCULO DA ÁREA DO TRIÂNGULO DEPENDE DOS SEUS VALORES DE ATRIBUTOS (LADO A, B e C)
LOGO, NÃO É UMA CLASSE ESTÁTICA.

-O CÁLCULO DA CIRCUNFERÊNCIA DE UM CÍRCULO DEPENDE DE SEU RAIO, MAS SE ESSE RAIO FOR UM
VALOR QUE ESTÁ NO PROGRAMA PRINCIPAL E NÃO UM ATRIBUTO DA CLASSE, ESSA CLASSE PODE SER ESTÁTICA.



*FUNÇÕES ESTÁTICAS SÓ PODEM USAR OUTRAS FUNÇÕES ESTÁTICAS;
static void Main(...){
    ...
    double volume = Volume(raio);
}

static Volume(){
    ...
}

*VARIÁVEIS/MÉTODOS USADAS EM FUNÇÕES ESTÁTICAS PRECISAM SER ESTÁTICAS

static double pi = 3.14;

static void Main(...){
    ...
    double volume = Volume(raio);
}

static Volume(){
    ....pi....
}



-----CONSTRUTORES-----
É A OPERAÇÃO QUE É EXECUTADA NO MOMENTO DE INSTANCIAÇÃO DE UM OBJETO.
PODE SER USADA PARA INICIAR VALORES DE ATRIBUTOS, CRIAR DEPENDÊNCIAS NO OBJETO ()

É POSSÍVEL TER MAIS DE UM CONSTRUTOR PARA A MESMA CLASSE (SOBRECARGA).

SOBRECARGA É UM RECURSO DE CLASSE QUE PERMITE TER MAIS DE UMA OPERAÇÃO COM O MESMO NOME
MAS COM DIFERENTES LISTAS DE PARÂMETROS.

EXEMPLO - CONSTRUTORES DA CLASSE PRODUTO COM SOBRECARGA

//CONSTRUTOR PADRÃO - SÓ PARA HABILITAR SEU USO
public Produto1()
{

}

//CONSTRUTOR COM TODOS OS DADOS
public Produto1(string nome, double preco, int quantidade)
{
    Nome = nome;
    Preco = preco;
    Quantidade = quantidade;
}

//CONTRUTOR COM NOME, PREÇO E QUANTIDADE 0
public Produto1(string nome, double preco)
{
    Nome = nome;
    Preco = preco;
    Quantidade = 0;//SEM ESSSA LINHA, POR PADRÃO, SERIA 0
}


E NO PROGRAMA PRINCIPAL
//USO DE CONSTRUTOR PERSONALIZADO
Produto1 produto1 = new Produto1(nome, preco);
//USO CONSTRUTOR PADRÃO
Produto1 produto2 = new Produto1();



-----SINTAXE ALTERNATIVA PARA CONSTRUTOR-----
AO INVÉS DE DEPENDER DO CONTRUTOR, O C# PERMITE INICIALIZAR OS ATRIBUTOS DIRETO NO PROGRAMA PRINCIPAL,
DESDE QUE NA CLASSE DO OBJETO, NÃO HAJA SOMENTE UM CONSTRUTOR ESPECÍFICO, MAS SIM TAMBÉM UM CONSTRUTOR PADRÃO E
QUE OS ATRIBUTOS NÃO SEJAM PRIVATE

NO PROGRAMA PRINCIPAL
Produto1 produto1 = new Produto1()
{
    Nome = "TV",
    Preco = 1500,
    Quantidade = 10
};



-----THIS-----
É USADA PARA REFERENCIAR O ATRIBUTO DA PRÓPRIA CLASSE, CASO HAJA ALGUMA OUTRA VARIÁVEL LOCAL DE MESMO NOME,
ALÉM DE SERVIR TAMBÉM PARA UTILIZAR AS INFORMAÇÕES DE OUTRO CONTRUTOR EM UM CONSTRUTOR E 
PASSAR O PRÓPRIO OBJETO COMO ARGUMENTO NA CHAMADA DE UM MÉTODO OU CONSTRUTOR.

THIS - DIFERENCIAR ATRIBUTOS DE VARIÁVEIS LOCAIS
public Produto(string Nome, double Preco){
    this.Nome = Nome;
    this.Preco = Preco;
    Quantidade = 0;
}


THIS - REFERENCIAR OUTRO CONSTRUTOR EM UM CONSTRUTOR

//CONSTRUTOR PADRAO
public Produto(){
    Quantidade = 0;
}

//2º CONSTRUTOR, QUE USA AS INFORMAÇÕES DO PADRAO 
public Produto (string nome, double preco) : this() {
    Nome = nome;
    Preco = preco;
}

//3º CONSTRUTOR, QUE USA AS INFORMAÇÕES DO 2º CONSTRUTOR
public Produto(string nome, double preco, int quantidade) : this(nome, preco) {
    Quantidade = quantidade;
}

NESSE CASO, O SEGUNDO CONTRUTOR JÁ VAI TER A INFORMAÇÃO DE QUE Quantidade = 0 PORQUE
ELE USOU AS INFORMAÇÕES DO CONSTRUTOR PADRÃO.
E O TERCEIRO CONSTRUTOR JÁ VAI TER AS INFORMAÇÕES DO SEGUNDO.



THIS - USAR O PRÓPRIO OBJETO DA CLASSE COMO ARGUMENTO NA CHAMADA DE UM DE SEUS MÉTODOS OU CONTRUTORES
class ChessMatch {
    ....
    PlaceNewPiece('e', 1, new King(board, Color.White, this));
    ...
}

NESSE CASO ACIMA, NA CLASSE ChessMatch, o método PlaceNewPiece UTILIZA O PRÓPRIO OBJETO DA CLASSE COMO ARGUMENTO.



-----ENCAPSULAMENTO-----
PRINCÍPIO QUE CONSISTE EM ESCONDER DETALHES DE IMPLEMENTAÇÃO DE UM COMPONENTE, EXPONDO APENAS
OPERAÇÕES SEGURAS E QUE O MANTENHA EM ESTADO CONSISTENTE.
A PRÓPRIA CLASSE DEVE GARANTIR ESSA CONSISTÊNCIA.

TODO ATRIBUTO PRIVATE (SÓ PODE SER ACESSADO PELA PRÓPRIA CLASSE)
E 
GET E SET PARA CADA ATRIBUTO (PERMITE IMPLEMENTAR LÓGICAS PARA GET E SET DOS ATRIBUTOS)
(NÃO É USUAl NO C#)

private string _nome;
private double _preco;
private int _quantidade;

public string GetNome()
{
    return _nome;
}

public void SetNome(string nome)
{
    _nome = nome;
}

UM ATRIBUTO PRIVATE MUDA SEU PADRÃO DE ESCRITA
private string _nome;



-----PROPERTIES NO LUGAR DE GETS E SETS-----
UMA PROPERTIE PODE SER USADA PARA TORNAR MAIS INTUITIVO O USO DOS ATRIBUTOS NO PROGRAMA PRINCIPAL E
MANTER A LÓGICA E SEGURANÇA NA IMPLEMENTAÇÃO DO SET E GET DOS ATRIBUTOS

COM GET E SET
NA CLASSE
public string GetNome()
{
    return _nome;
}

public void SetNome(string nome)
{
    //NOME SÓ É MODIFICADO SE NÃO FOR VAZIO E TIVER MAIS QUE UMA LETRA
    if (nome != null && nome.Length > 1)
    {
        _nome = nome;
    }
}

NO PROGRAMA PRINCIPAL
produto1.SetNome("TVZONA");
string nome = produto1.GetNome();
Console.WriteLine(nome);



COM PROPERTIE APLICADA AO GET E SET DE _nome
NA CLASSE
public string Nome
{
    get { return _nome; }
    set {
        if (value != null && value.Length > 1)//value VAI SER OQ ESTIVER SENDO ATRIBUÍDO AO NOME, NO PROGRAMA PRINCIPAL
        {
            _nome = value;
        }
    }
}

NO PROGRAMA PRINCIPAL
produto1.Nome = "TVZONA";
string nome = produto1.Nome; //USO DO GET PELA PROPERTIE
Console.WriteLine(nome);


-----AUTO PROPERTIES (PROPRIEDADES AUTO IMPLEMENTADAS)-----
SÃO PROPERTIES SIMPLIFICADAS QUE PODEM SER UTILIZADAS PARA ATRIBUTOS QUE NÃO PRECISAM DE NENHUM LÓGICA INTERNA ELABORADA

AUTO PROPERTIE PARA OS ATRIBUTOS PREÇO E QUANTIDADE DA CLASSE PRODUTOS
NA CLASSE
public double Preco { get; private set; }
public int Quantidade { get; private set; }
//private set DETERMINA QUE O MÉTODO set DESSES ATRIBUTOS SÓ É ACESSÍVEL NA CLASSE

SUBSTITUINDO AS PROPERTIES MANUAIS
public double Preco
{
    get { return _preco; }
}

public int Quantidade
{
    get { return _quantidade; }
}

NO PROGRAMA PRINCIPAL
//DA MESMA FORMA QUE ANTERIORMENTE
produto1.Nome = "TVZONA";
string nome = produto1.Nome; //USO DO GET PELA PROPERTIE
Console.WriteLine(nome);




-----MODIFICADORES DE ACESSO-----

PARA MEMBROS DAS CLASSES

                      própria classe   subclasse no assembly   classes do assembly   subclasse fora do assembly   classes fora do assembley
public              |       X                   X                       X                        X                           X

protected internal  |       X                   X                       X                        X                           

internal            |       X                   X                       X                                                    

protected           |       X                   X                                                X                           

private protected   |       X                   X                                                                            

private             |       X                                                                    X                           


*assembly == projeto

PARA CLASSES
CLASSE ACESSÍVEL POR QUALQUER OUTRA - public class
CLASSE ACESSÍVEL SOMENTE NO PROJETO - internal class (padrão)
CLASSE ACESSÍVEL SOMENTE PELA CLASSE MÃE (CLASSE MAIOR QUE TEM A MENOR DENTRO DELA) - private class



-----BOAS PRÁTICAS-----
ORDEM DE IMPLEMENTAÇÃO NA CLASSE
-ATRIBUTOS PRIVADOS
-AUTOPROPERTIES
-CONSTRUTORES
-PROPERTIES MANUAIS
-DEMAIS MÉTODOS


-----VARIÁVEIS POR REFERÊNCIA (PONTEIROS) E VARIÁVEIS POR VALORES (STRUCTS)------

PONTEIRO
TODO OBJETO DE UMA CLASSE É PONTEIRO
QUANDO O OBJETO É DECLARADO, SEU NOME É UM PONTEIRO.
*UM PONTEIRO PODE RECEBER VALOR null, O QUE RESERVA NA MEMÓRIA UM ESPAÇO COM VALOR null/0/ESPECÍFICO DA MEMÓRIA.

Produto p1;   //CRIA NA MEMÓRIA UM PONTEIRO p1 QUE AINDA NÃO APONTA PARA NADA
p1 = new Ponteiro("TV", 1300.00, 15);

AGORA NA MEMÓRIA STACK, O p1 PONTEIRO GUARDA UM ENDEREÇO DA MEMÓRIA HEAP.
NESSE ENDEREÇO ESTÃO AS INFORMAÇÕES DO OBJETO
 
---------------------------------------------------------
     STACK                         VARIÁVEL APONTADA

   MEMÓRIA STACK                      MEMÓRIA HEAP  
                             
     0x100358                      TV   |  1300  | 15
    ----------      ==========>    -------------------
        p1
---------------------------------------------------------

Produto p2;
p2 = p1;

AGORA TANTO p2 QUANTO p1 APONTAM PARA O MESMO ENDEREÇO DE MEMÓRIA

---------------------------------------------------------
     STACK                          VARIÁVEL APONTADA

   MEMÓRIA STACK                      MEMÓRIA HEAP  
                             
     0x100358                      TV   |  1300  | 15
    ----------      ==========>    -------------------
        p1                        // 
                                 //
     0x100358                   //
    ----------      ===========//
        p2
---------------------------------------------------------



STRUCT
TODAS DECLARAÇÃO DE VARIÁVEIS "SIMPLES" - int double byte long float char....- SÃO VARIÁVEIS DO TIPO STRUCT
ALÉM DOS TIPOS DateTime e TimeSpan
O VALOR ATRIBUÍDO A ELAS NÃO ENVOLVE REFERÊNCIA E NEM MESMO A MEMÓRIA HEAP, APENAS CÓPIA.

double x,y;

x = 10;
y = x;
//y RECEBE UMA CÓPIA DO VALOR DE x

---------------------------------------------------------

       STACK                        VARIÁVEL APONTADA

   MEMÓRIA STACK                      MEMÓRIA HEAP  
                             
        10                     
    ---------                            
        x


        10                     
    ---------                            
        y

---------------------------------------------------------

STRUCTS PODEM SER CRIADOS, ASSIM COMO CLASSES, PARA GUARDAR VALORES COMPOSTOS
CONSIDERANDO QUE STRUCTS NÃO TEM TODOS OS RECURSOS DE UMA CLASSE.
BOTÃO DIREITO NO PROJETO - ADD - CLASS - NOMEAR - TROCAR class POR struct

UM STRUCT QUE REPRESENTA UM PONTO CARTESIANO

namespace PrimeiroProjeto{
    struct Point{
        public double X,Y;

        public override string ToString(){
            return $"({X},{Y})";
        }
    }
}


NO PROGRAMA PRINCIPAL
//Point ponto; //NÃO FUNCIONA
Point ponto = new Point();

ponto.X = 20;
ponto.Y = 10;
Console.WriteLine(ponto);

NO STRUCT, TAMBÉM PODEM SER USADOS CONTRUTORES
NO PROGRAMA PRINCIPAL
Point ponto = new Point();
Console.WriteLine(ponto);
//VALORES DOUBLE INICIADOS COM 0 0



-----VALORE PADRÃO PARA TIPOS DE VARIÁVEIS-----
CASO NÃO SEJA ATRIBUÍDO DIRETAMENTE, AS VARIÁVEIS DECLARADAS ASSUMEM VALORES PADRÃO
NÚMEROS - 0
BOOL - false
CHAR - CARACTERE CÓDIGO 0
OBJETO - null


-----GARBAGE COLLECTOR-----
MECANISMO DE DESALOCAÇÃO DE MEMÓRIA

-DESALOCAÇÃO PARA PONTEIROS
SE UM PONTEIRO p APONTA PARA UMA POSIÇÃO 0xAAAA QUE CONTÉM DADOS,
E EM ALGUM MOMENTO O PONTEIRO p PASSA A APONTAR PARA OUTRA POSIÇÃO,
A POSIÇÃO 0xAAAA FICA SEM NENHUMA REFRÊNCIA A ELA E É DESALOCADA. 


-DESALOCAÇÃO PARA ESCOPO
UMA VARIÁVEL x EXISTE SOMENTE DENTRO DE UM LAÇO WHILE, ASSUMINDO VALORES DEFINIDOS PELA LÓGICA.
QUANDO O LAÇO TERMINAR, A VARIÁVEL x É DADA COMO null/0/false... (VARIÁVEL NÃO ATRIBUÍDA).



-----NULLABLE-----
UM RECURSO QUE PERMITE TORNAR VARIÁVEIS QUE SÃO VALORES (NÃO PONTEIROS) COMO null.
ATÉ AGORA, SOMENTE VALORES DE PARÂMETRO POR REFERÊNCIA PODEM ASSUMIR VALORES null,
E SE QUISERMOS O PREENCHIMENTO OPCIONAL DE UMA VARIÁVEL int, float, byte, double... ?
PODEMOS TORNÁ-LAS NULLABLE.

double x; //DECLARAÇÃO PADRÃO

Nullable<double> x = null; //USANDO NULLABLE

double? x = null;//USANDO NULLABLE SIMPLIFICADO



OPERAÇÕES PARA NULLABLE
x.GetValueOrDefault();
RETORNA O VALOR ASSUMIDO PELA VARIÁVEL, OU O VALOR PADRÃO PARA SEU TIPO
ÚTIL PARA SABER QUAIS VALORES UMA VARIÁVEL NULLABLE PODE ASSUMIR.

x.HasValue;
ÚTIL PARA SABER SE UMA VARIÁVEL ESTÁ PREENCHIDA OU NÃO.
RETORNA true CASO A VARIÁVEL NULLABLE TENHA ALGUM VALOR ASSUMIDO
RETORNA false NO CASO CONTRÁRIO.

x.Value;
RETORNA O VALOR DE UMA VARIÁVEL NULLABLE
!! SE NÃO EXISTIR VALOR, OU SEJA, FOR null, DÁ ERRO.
BOM USAR COM IF - if (x.HasValue){.....}


OPERADOR DE COALESCÊNCIA NULA
USADO NUM CONTEXTO DE PRECISAR ATRIBUIR PARA UMA VARIÁVEL QUALQUER O VALOR DE UMA VARIÁVEL NULLABLE
UMA VARIÁVEL double? x DE VALOR null.
ATRIBUIR PARA double y O VALOR DE x

PROBLEMA
SE x É null, O QUE SERÁ ATRIBUÍDO PARA y ?
NESSE CASO, PARA EVITAR A EXCEÇÃO, USAR O OPERADOR DE COALESCÊNCIA (??)

double? x = null;
double y = x ?? 0;
//CASO O VALOR DE x SEJA null, Y RECEBE 0


-----VETORES-----
UM ARRANJO UNIDIMENSIONAL
HOMOGÊNIO - SÓ ACEITA DADOS DO MESMO TIPO
ACESSÍVEL VIA POSIÇÃO - 0 A N
ALOCAÇÃO ESTÁTICA - TAMANHO FIXO - NUM BLOCO CONTÍGUO DE MEMÓRIA
-ACESSO IMEDITADO :)
-DIFICULDADE DE INSERIR E DELETAR ELEMENTOS :(

TODO NOME DE VETOR É UM PONTEIRO PARA SEUS VALORES NA MEMÓRIA HEAP
DECLARAÇÃO
<tipo vetor>[] <nome vetor> = new <tipo vetor>[<tamanho vetor>]
double[] vetor1 = new double[10]; //VETOR DE doubles COM 1O POSIÇÕES (0 a 9)

CRIAÇÃO ESPONTÂNEA DE VETOR
JÁ CRIAR PREENCHENDO
int[] vetor2 = new int[] {1, 3, 5, 9}; 


VETOR DE OBJECTS
É POSSÍVEL CRIAR VETORES DE OBJETOS, NO QUAL CADA POSIÇÃO É UM OBJETO COM TODOS SEUS ATRIBUTOS
Product[] vetor1 = new Product[10]; //VETOR COM 10 OBJETOS

     STACK                               VETOR DE OBJETOS

   MEMÓRIA STACK                           MEMÓRIA HEAP  
                                       --------------------
                             
     0x100358                          |      TV  | 1300  
    ----------      ==========>        | ---------------
      vetor1                           |    JBL   | 2000 
                                       | ---------------
                                       | AIRFRYER | 750



-----PARAMS-----
COMO CRIAR UMA FUNÇÃO QUE ACEITA UM NÚMERO VARIÁVEL DE ARGUMENTO?
USAR VETOR

NA CLASSE

//FUNÇÃO QUE RETORNA A SOMA DOS VETOR PASSADO NOS PARÂMETROS
internal static double Sum(int[] numbers)
{
    double sum = 0;
    for(int i = 0; i < numbers.Length; i++)
    {
        sum += numbers[i];
    }
    return sum;
}

NO PROGRAMA PRINCIPAL
double soma1 = Calculator.Sum(new int[] { 2, 5, 3 });
//new int[] { 2, 5, 3 } - CRIA UM VETOR DE INTEIROS COM OS ELEMENTOS ENTRE CHAVES


O PROGRAMA AINDA PODE SER MELHORADO USANDO PARAMS NA CONSTRUÇÃO DA FUNÇÃO, SENDO PRECISO 
APENAS ADICIONAR A PALAVRA params
NA CLASSE

//FUNÇÃO QUE USA OS VALORES PASSADOS COMO PARÂMETRO PARA PREENCHER O SEU VETOR E GERAR A SOMA
internal static double Sum(params int[] numbers)
{
    double sum = 0;
    for(int i = 0; i < numbers.Length; i++)
    {
        sum += numbers[i];
    }
    return sum;
}


NO PROGRAMA PRINCIPAL
double soma1 = Calculator.Sum(2, 5, 3, 9); 

AGORA SEM A NECESSIDADE DE INSTANCIAR UM VETOR AQUI NOS PARÂMETROS, O PROGRAMA JÁ ENTENDE QUE OS PARÂMETROS PASSADOS SERÃO INSERIDOS NO VETOR
QUE ESTÁ NA CONSTRUÇÃO DA FUNÇÃO.



-----MODIFICADORES DE PARÂMETRO REF E OUT :(-----
REF
UMA FUNÇÃO VOID QUE USA VALORES STRUCT NÃO PROMOVE MODIFICAÇÕES NESSA VARIÁVEL.
POR EXEMPLO, CRIAR UMA FUNÇÃO QUE TRIPLIQUE O VALOR DE SUA VARIÁVEL PASSADA NO PARÂMETRO.

NA CLASSE
internal static void Triple(int x)
{
    x = x * 3;
}

NO PROGRAMA PRINCIPAL
int a = 10;
Calculator.Triple(a);
Console.WriteLine(a);

a CONTINUA VALENDO 10 PORQUE USAR VARIÁVEIS STRUCT COMO PARÂMETRO, FAZ COM QUE O PROGRAMA CRIE UMA CÓPIA DE a NA MEMÓRIA HEAP (AQUI CHAMADA DE x), PROCESSE ESSA CÓPIA COM O FUNCIONAMENTO DA FUNÇÃO, E ASSIM QUE A FUNÇÃO TERMINA DE EXECUTAR, ESSE VALOR É APAGADO PELO GARBAGE COLLECTOR, NÃO HAVENDO NENHUMA MODIFICAÇÃO PARA a.

   MEMÓRIA STACK                      MEMÓRIA HEAP  
                                  --------------------
                             
      10                                  30    
    ------        (sem ligação)         --------
      a                                   x 
                                       

PARA RESOLVER ESSA SITUAÇÃO E CRIAR UMA REFERÊNCIA DE x PARA a (OU SEJA, O QUE ACONTECER COM x, ACONTECE COM a), USAR REF

NA CLASSE
internal static void Triple(ref int x)
{
    x = x * 3;
}

NO PROGRAMA PRINCIPAL
int a = 10;
Calculator.Triple(ref a);
Console.WriteLine(a);

   MEMÓRIA STACK                      MEMÓRIA HEAP  
                                  --------------------
                             
      30                                  30    
    ------        <============        --------
      a                                   x 



OUT
UMA MANEIRA DE SIMULAR O QUE O REF FAZ, MAS AO INVÉS DE USAR UMA VARIÁVEL x COMO REFERÊNCIA PARA a, CRIA-SE UMA VARIÁVEL result (POR EXEMPLO) QUE VAI GUARDAR O RESULTADO DA FUNÇÃO E ATRIBUIR A OUTRA VARIÁVEL NO PROGRAMA PRINCIPAL, b por exemplo. 

NA CLASSE
internal static void Triple(int origin, out int result)
{
    result = origin * 3;
}

NO PROGRAMA PRINCIPAL
int a = 10;
Calculator.Triple(a, out int b);
Console.WriteLine(b);


*VARIÁVEL ref PRECISA TER SIDO INICIADA (ATRIBUÍDO VALOR). VARIÁVEL out, NÃO
*AMBOS SÃO CONSIDERADOS PRÁTICAS RUINS.



-----BOXING E UNBOXING-----
BOXING
CRIAR UMA VARIÁVEL DO TIPO REFERÊNCIA (Object, vector, ponteiro) QUE RECEBE O VALOR DE UMA VARIÁVEL DO TIPO STRUCT

int x = 50;
Object obj = x;

   MEMÓRIA STACK                      MEMÓRIA HEAP  
                                  --------------------
                             
      50                                  50    
    ------                             --------
      x                              // 
                                    //
    0x100358                       //
   ----------      ===============//
      obj


UNBOXING
CRIAR UMA VARIÁVEL STRUCT QUE RECEBE O VALOR DE UMA VARIÁVEL DE REFERÊNCIA 
O VALOR DO OBJETC PRECISAR SER COMPATÍVEL COM O TIPO DA VARIÁVEL STRUCT

int x = 10;
Object obj = x;
int y = (int)obj;

   MEMÓRIA STACK                      MEMÓRIA HEAP  
                                  --------------------
                             
      50                                  50    
    ------                             --------
      x                              // 
                                    //
    0x100358                       //
   ----------      ===============//
      obj

      50
    ------
      y



-----FOR EACH-----
LAÇO DE REPETIÇÃO PARA PERCORRER COLEÇÕES
MUITO USADO PARA PERCORRER SEQUÊNCIAS DE OBJETOS

CONSIDERANDO UM VETOR DE OBJETOS DO TIPO Point
CADA OBJETO POINT E UM CONJUNTO DE DUAS COORDENADAS X E Y.
CADA REPETIÇÃO DO LAÇO MOSTRA OS DOIS PONTOS.

foreach(Point obj in vetor_coordenadas)
{
    Console.WriteLine(obj);
}



-----LISTAS-----
HOMOGÊNEA
CADA ELEMENTO OCUPA UMA POSIÇÃO (0 A N)
INICIA VAZIA E É PREENCHIDA SOB DEMANDA - NÃO É ESTÁTICA COMO O VETOR
MAIS FÁCIL DE REALIZAR INSERÇÕES E DELEÇÕES

DESVANTAGEM - ACESSO SEQUENCIAL AOS ELEMENTOS
É UMA LISTA ENCADEADA - CADA ELEMENTO TEM SEU VALOR E UM PONTEIRO PARA A PRÓXIMA POSIÇÃO DA LISTA
MAS HÁ IMPLEMENTAÇÕES QUE OTIMIZAM ESSE ACESSO PARA SER MAIS RÁPIDO, COMO EM VETORES

NECESSÁRIO USAR A CLASSE List
using System.Collections.Generic;

DECLARAÇÃO
List<string> lista1 = new List<string>(); //LISTA VAZIA
List<string> lista2 = new List<string>{"Luciano", "Goiaba", "Ana"}; //LISTA VAZIA

CONSIDERANDO UMA LISTA lista1

INSERÇÃO
---
Add - INSERE UM ITEM AO FINAL
lista1.Add("Luciano");
lista1.Add("Ana");
lista1.Add("Alex");


---
Insert(x,item) - INSERE NA POSIÇÃO x O ITEM
lista1.Insert(1, "Lucas");


INFORMAÇÕES
---
Count - TAMANHO DA LISTA
Console.WriteLine(lista1.Count); 


BUSCA NA LISTA
---
lista1.Find(<expressão lambda>) - ENCONTRA NA LISTA A PRIMEIRA OCORRÊNCIA DE UM ELEMENTO QUE SATISFAÇA A FUNÇÃO lambda

EX: ENCONTRAR A PRIMEIRA PESSOA DA LISTA CUJO NOME COMEÇA COM A

string nome_com_a = lista1.Find(x => x[0] == 'A');
//x => x[0] == 'A'  -- EXPRESSÃO LAMBDA QUE DENOTA "ENCONTRAR O ELEMENTO X, TAL QUE A PRIMEIRA POSIÇÃO DE X SEJA 'A'
Console.WriteLine(nome_com_a);


---
lista1.FindLast(<expressão lambda>) 
...


---
list.FindIndex(<expressão lambda>) - ENCONTRA NA LISTA A PRIMEIRA POSIÇÃO CUJO ELEMENTO SATISFAÇA A FUNÇÃO LAMBDA

EX: ENCONTRAR A POSIÇÃO DO ELEMENTO QUE SEJA Alex

int pos = lista1.FindIndex(x => x == "Alex");
Console.WriteLine($"Posição cujo nome é Alex: {pos}");
Console.WriteLine();

//RETORNA -1 CASO NÃO ENCONTRE


---
list.FindLastIndex
...


---
list.FindAll(<expressão lambda>) - FILTRA PARA OUTRA LISTA OS ELEMENTOS QUE SATISFAÇAM A EXPRESSÃO

EX: CRIAR UMA LISTA COM TODOS OS NOMES QUE TENHA 5 LETRAS

List<string> lista2 = new List<string>();
lista2 = lista1.FindAll(x => x.Length == 5);

---
Remove(item) - REMOVER DA LISTA O ITEM
lista1.remove("Luciano");

---
RemoveAll(<expressão lambda>) - REMOVE TODOS DA LISTA QUE SATISFAÇAM A EXPRESSÃO LAMBDA

EX: REMOVER TODOS QUE COMEÇAM COM A
lista1.RemoveAll(x => x[0] == 'A');

---
RemoveAt(pos) - REMOVE O ELEMENTO DA POSIÇÃO ESPECÍFICA
lista1.RemoveAt(2)

---
RemoveRange(X, N) - REMOVE, A PARTIR DA POSIÇÃO X, N ELEMENTOS
lista1.RemoveRange(1, 2);



-----MATRIZES-----
COMO VETORES, PORÉM, BIDIMENSIONAL
-HOMOGÊNIA - SÓ ACEITA DADOS DO MESMO TIPO
ACESSÍVEL VIA POSIÇÃO - 0 A N (LINHA) E 0 A N (COLUNA)
ALOCAÇÃO ESTÁTICA - TAMANHO FIXO - NUM BLOCO CONTÍGUO DE MEMÓRIA
-ACESSO IMEDITADO :)
-DIFICULDADE DE INSERIR E DELETAR ELEMENTOS :(

TODO NOME DE MATRIZ É UM PONTEIRO PARA SEUS VALORES NA MEMÓRIA HEAP
DECLARAÇÃO
<tipo matriz>[,] <nome> = new <tipo matriz>[x,y]
//x - LINHAS
//y - COLUNAS

double[,] matriz = new double[2,3];



---PROPRIEDADES DA MATRIZ---
Length - QUANTOS ELEMENTOS A MATRIZ TEM
Console.WriteLine(matriz.Length); - //6

Rank - QUANTAS LINHAS A MATRIZ TEM
Console.WriteLine(matriz.Rank); //2

GetLength(x) - RETORNA O NÚMERO DE ITENS NA DIMENSÃO X, SENDO x
0 - PRIMEIRA DIMENSÃO - LINHAS
1 - SEGUNDA DIMENSÃO - COLUNAS
//ÚTIL PARA PERCORRER A MATRIZ



-----TÓPICOS ESPECIAIS-----

---VAR---
É POSSÍVEL USAR A PALAVRA var NO LUGAR DO TIPO DA VARIÁVEL, NA DECLARAÇÃO.
POR INFERÊNCIA, O COMPILADOR DEFINE QUAL O TIPO DA VARIÁVEL PELO SEU VALOR ASSUMIDO.
É ÚTIL, PORÉM, PERIGOSO, DADO QUE NADA IMPEDE QUE UMA VARIÁVEL var NÃO ASSUMA ACIDENTALMENTE
UM VALOR DO TIPO ERRADO, CASO HAJA ALGUM DESCUIDO DA PARTE DO PROGRAMADOR.

var x = 10; //x É INTEIRO
var nome = "Luciano"; // nome É string
var nome1 = 25.75; //nome1 É double, O QUE FOI PERMITIDO MAS NÃO TEM MUITO SENTIDO


---SWITCH CASE---
LAÇO DE REPETIÇÃO QUE PODE SER USADO NO LUGAR DO IF-ELSE IF-ELSE.
QUANDO A CONDIÇÃO DEPENDE DO VALOR ASSUMIDO POR UMA VARIÁVEL.

int x = int.Parse(Console.ReadLine());
if(x == 1)
{
    Console.WriteLine("First");
}
else if(x == 2)
{
    Console.WriteLine("Second");
}
else if (x == 3)
{
    Console.WriteLine("Third");
}
else
{
    Console.WriteLine("Not in podium");
}

COM SWITCH CASE
switch(x)
{
    case 1:
        Console.WriteLine("First");
        break;

    case 2:
        Console.WriteLine("Second");
        break;

    case 3:
        Console.WriteLine("Third");
        break;

    default:
        Console.WriteLine("Not in podium");
        break;
}



---CONDICIONAL TERNÁRIA---
EXPRESSÃO QUE PODE SUBSTITUIR UM IF-ELSE SIMPLES.
ELA DEFINE UM RETORNO OU OUTRO, SE UMA CONDIÇÃO É VERDADEIRA OU FALSA

variavel = (condição) ? valor_para_true : valor_para_false;

double preco = double.Parse(Console.ReadLine(), CultureInfo.InvariantCulture);
double desconto = (preco > 50) ? preco * 0.1 : preco * 0.05;
Console.WriteLine(desconto);
//CASO O PREÇO SEJA MAIOR QUE 50, O DESCONTO É DE 10%
//CASO NÃO SEJA, O DESCONTO É DE 5%


---FUNÇÕES PARA STRING---
ToUpper() - RETORNA UMA STRING COMO TODOS CARASTÉRES MAIÚSCULOS
ToLower() - MINÚSCULO
Trim() - APAGA ESPAÇOS EM BRANCO NO INÍCIO E FINAL
Split("x") - SEPARA A STRING EM STRINGS MENORES USANDO O x COMO SEPARADOR - O x PODE SER ESPAÇO EM BRANCO, VÍRGULA, - ELE NÃO É INCLUSO
IndexOf(x) - RETORNA A POSIÇÃO DA PRIMEIRA OCORRÊNCIA DE x NA STRING
LastIndexOf(x) - ÚLTIMA OCORRÊNCIA
Substring(x) - RETORNA A STRING A PARTIR DA POSIÇÃO x
Substring(x,n) - RETORNA A STRING DE TAMANHO n A PARTIR DA POSIÇÃO x
Replace('a','b') - RETORNA UMA STRING TROCANDO TODO CARACTERE a POR b
Replace("a","b") - TROCANDO TODO TRECHO a POR b
String.IsNullOrEmpty(frase) - RETORNA UM VALOR BOOL true CASO A STRING frase ESTEJA VAZIA OU SEJA NULL //COM ESPAÇO - false
String.IsNullOrWhiteSpace(frase) - true CASO ESTEJA VAZIA, SÓ ESPAÇOS EM BRANCO OU NULL


---DATETIME---

CONSTRUTORES COM SOBRECARGA
Datetime d1 = new DateTime(2025, 03, 17);
//INSTANCIA O DATETIME 17/03/2025 00:00:00

Datetime d1 = new DateTime(2025, 03, 17, 15, 30, 25);
//INSTANCIA O DATETIME 17/03/2025 15:30:25

Datetime d1 = new DateTime(2025, 03, 17, 15, 30, 25, 500);
//INSTANCIA O DATETIME 17/03/2025 15:30:25 PORQUE A FORMATAÇÃO PADRÃO NÃO CONSIDERA OS MILISEGUNDOS


USANDO BUILDERS
DateTime d1 = Datetime.Now; 
DD/MM/AAAA HH:MM:SS

DateTime d1 = Datetime.Today; 
DD/MM/AAAA 00:00:00

DateTime d1 = Datetime.UtcNow;
DD/MM/AAAA HH:MM:SS NA LINHA DE GREEWICH



---USANDO PARSE---
PARSE PERMITE CONVERTER DATAS/HORÁRIO EM STRING PARA DATETIME

DateTime d1 = DateTime.Parse("2025-03-17");
17/03/2025 00:00:00

DateTime d1 = DateTime.Parse("2025-03-17 15:30:25");
17/03/2025 15:30:25

*Brasileiro
DateTime d1 = DateTime.Parse("17/03/2025");
17/03/2025 00:00:00

*Brasileiro
DateTime d1 = DateTime.Parse("17/03/2025 15:30:25");
17/03/2025 15:30:25


---PARSE EXACT---
PERMITE INFORMAR UMA STRING NUM FORMATO E INDICAR, NESSE FORMATO, O QUE DEVE SER INTERPRETADO COMO DIA MÊS ANO HORA MINUTO SEGUNDO

DateTime d1 = DateTime.ParseExact("2025-03-17", "yyy-MM-dd",CultureInfo.InvariantCulture);
//FOI INDICADO QUE OS PRIMEIROS 4 DIGITOS SÃO O ANO, OS DOIS PRÓXIMOS SÃO MESES E OS DOIS ÚLTIMOS SÃO DIAS

DateTime d1 = DateTime.ParseExact("17/03/2025 15:30:25", "dd/MM/yyyy HH:mm:ss",CultureInfo.InvariantCulture);
//PRIMEIROS 4 DIGITOS SÃO O ANO, OS DOIS PRÓXIMOS SÃO MESES E OS DOIS ÚLTIMOS SÃO DIAS - HORAS, MINUTOS, SEGUNDOS

DENTRE OUTRAS....



---TIMESPAN---

























-----RASCUNHOS-----
SABER SE VARIÁVEL ESTÁ VAZIA
STRING
nome == null

NUMÉRICA
valor == 0 (POR PADRÃO, NÚMEROS ASSUMEM VALOR 0)

SABER TAMANHO DA STRING
nome.Legth > 1



-----UML-----

REPRESENTAÇÃO DE CLASSE NA UML

------------------------------------------
                NOME CLASSE
------------------------------------------
             -ATRIBUTO: TIPO;
             -ATRIBUTO: TIPO;
------------------------------------------
    +MÉTODO(<PARAMETROS>): <TIPO RETORNO>
    +MÉTODO(<PARAMETROS>): <TIPO RETORNO>
------------------------------------------














